# 项目规则与开发指南

## 1. 项目概述与技术架构

本项目是一个 Android 电池状态记录工具，旨在精确、持续地监控和记录设备的详细电量信息。

项目采用经典的**客户端-服务器 (Client-Server)** 架构：

*   **客户端 (`app` 模块)**: 作为用户界面 (UI) 和配置控制器。
*   **服务器 (`server` 模块)**: 作为后台核心服务，负责所有的数据采集和存储。

两者通过 **AIDL (Android 接口定义语言)** 进行进程间通信 (IPC)。

**核心技术栈:**

*   **Kotlin**: 主要用于 `app` 模块的 UI 和逻辑。
*   **Java**: 主要用于 `server` 模块的核心服务。
*   **AIDL**: 用于实现 `app` 和 `server` 之间的跨进程通信。
*   **Android Hidden API**: 用于访问系统私有接口，以实现高级功能（如前台应用追踪）。

---

## 2. 代码结构与模块说明

项目包含三个核心模块：`app`, `server`, `hiddenapi`。

*   ### `app` 模块
    *   **职责**:
        1.  提供用户界面，用于展示服务状态和配置项。
        2.  作为配置控制器，允许用户修改采样频率、批量大小等参数，并将变更通知给 `server`。
        3.  接收 `server` 主动推送的 Binder 对象，建立通信。
    *   **关系**: 依赖 `server` 模块提供的 AIDL 接口来发送控制命令。

*   ### `server` 模块
    *   **职责**:
        1.  **核心业务逻辑**: 实现所有的数据采集、处理和存储。
        2.  **高权限运行**: 必须在 `root` 或 `shell` 权限下运行，以便直接读取 `/sys` 文件系统中的原始电池数据。
        3.  **服务调度**: 管理数据采集任务的生命周期，并使用 `ITaskStackListener` 追踪前台应用。
        4.  **通信服务**: 实现 AIDL 接口，响应来自 `app` 的控制请求。
    *   **关系**: 编译时依赖 `hiddenapi` 模块来链接系统私有 API。它不依赖 `app`，但会主动与 `app` 建立通信。

*   ### `hiddenapi` 模块
    *   **职责**:
        1.  一个存根 (Stub) 库，仅包含 Android 系统私有 API 的方法签名。
        2.  其唯一目的是让 `server` 模块在编译时能够成功链接到这些私有 API，而不会在运行时被直接使用（运行时会调用系统真正的实现）。
    *   **关系**: 是 `server` 模块的一个编译时依赖 (`compileOnly`)。

---

## 3. 关键业务逻辑与数据流

### 数据流 (单向)
数据流严格在 `server` 模块内部单向流动并最终落盘：

1.  **数据采集 (`PowerUtil.java`)**:
    *   作为数据的唯一来源。
    *   直接从 `/sys/class/power_supply/battery/` 目录下的文件中读取原始、未经处理的电池数据（如电压、电流）。
    *   此操作需要高权限。

2.  **数据调度 (`Server.java`)**:
    *   作为 `server` 模块的大脑。
    *   根据配置的采样频率，周期性地调用 `PowerUtil` 来获取数据。

3.  **数据存储 (`PowerDataStorage.java`)**:
    *   作为数据的唯一出口。
    *   从 `Server.java` 接收数据。
    *   **批量写入**: 将数据缓存起来，达到一定数量后一次性写入文件，以减少 I/O 开销。
    *   **分段存储**: 根据电池的充电/放电状态，将数据写入到不同的文件中，便于后续分析。

### 控制流 (`app` -> `server`)
控制流由 `app` 发起，通过 AIDL 调用 `server` 的方法：

1.  **通信建立 (`BinderProvider.kt`)**:
    *   `server` 进程启动后，会检测 `app` 进程是否在前台。
    *   一旦检测到，`server` 会主动通过 `ContentProvider` 机制，将自身的 Binder "推送"给 `app`。

2.  **配置变更 (`SettingsFragment.kt` -> `Server.java`)**:
    *   用户在 `app` 的设置界面修改了配置（如采样间隔）。
    *   配置被写入 `SharedPreferences`。
    *   `app` 通过 AIDL 调用 `server` 的 `refreshConfig()` 方法。
    *   `Server.java` 收到调用后，重新从 `SharedPreferences` 加载配置。

3.  **服务停止 (`MainActivity.kt` -> `Server.java`)**:
    *   用户在 `app` 点击停止按钮。
    *   `app` 通过 AIDL 调用 `server` 的 `stopService()` 方法，`server` 进程退出。
    *   **注意**: `server` 的启动由外部脚本控制，`app` 无法启动它。

---

## 4. 开发注意事项与约束条件 (必须遵守)

1.  **权限**: `server` 模块必须在 `root` 或 `shell` 权限下运行，否则无法工作。
2.  **逻辑分离**: 所有核心业务逻辑（数据采集、处理、存储）**必须**在 `server` 模块中实现。
3.  **`app` 角色**: `app` 模块**严格**作为 UI 和配置控制器，**禁止**包含任何数据处理或文件读写逻辑。
4.  **通信接口**: 模块间的任何新功能或数据交换，**必须**通过扩展现有的 `IService.aidl` 接口来实现。
5.  **数据格式**: 数据存储格式（分段、批量写入）**必须**保持一致，任何修改都需在 `PowerDataStorage.java` 中统一进行。
6.  **配置管理**: 配置由 `app` 修改，存储在 `SharedPreferences` 中，`server` 仅负责读取和响应 `refreshConfig()` 调用来重新加载。

---

## 5. 编码规范与最佳实践

*   **单一职责原则**:
    *   所有文件 I/O 操作应封装在 `PowerDataStorage.java` 中。
    *   所有与系统底层硬件 API (`/sys/`) 的交互应封装在 `PowerUtil.java` 中。
*   **接口清晰**: 保持 AIDL 接口的简洁和明确，只暴露必要的控制方法。
*   **逻辑分离**: 严格分离 UI 交互逻辑 (`app`) 和后台服务逻辑 (`server`)，避免耦合。